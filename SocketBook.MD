### Что такое многопоточность


### Что такое асинхронность
**Асинхронность** - означает то, что при выполнении какого-либо действия не ожидается немедленный результат (ответ) - т.е. не ожидается мгновенный результат.

### Что такое concurrency


---

### Что такое блокирующий IO
Блокирующий I/O - полная противоположность неблокирующего. При вызове блокирующего api поток, из которого была вызвана функция, заблокируется, ожидая ответа. То есть поток
будет простаивать в это время, не делая какую либо полезную работу, а просто тратя время неэффективно.

Например, функции read, write при выполнении на блокирующем сокете заблокируют поток в ожидании ответа, пока другая сторона tcp-соединения не пришлет данные.
Блокировки и проблема пустого, неэффективного траты времени вследствие этого могут быть решены 2 способами:
1) Сделать nonblocking i/o
2) Сделать мультиплексирование

---

### Что такое неблокирующий IO
Неблокирующий I/O - означает то, что при вызове неблокирующего api программа продолжит работать дальше, не простаивая, то есть к ней сразу же вернется управление.
Однако, так как данные могут быть еще не готовы, то вместо данных вернется результат *-1* и ошибка *EWOULDBLOCK*.
Соответственно, нам придется опрашивать все файловые дескрипторы в цикле, и только при готовности данных обработать.

Но такой подход имееет минусы, поскольку:
1) Потребуется многократно опрашивать сокеты и вследствие этого лишняя нагрузка на процессор
2) при увеличении кол-ва сокетов, с таким подходом нагрузка возрастет еще сильнее и расходы на проверку готовности данных возрастут

То есть опрашивать постоянно в цикле - неэффективно, и принципиальных отличий в времени от блокирующего режима в принципе то и нет.
Поэтому тут приходит на помощь решение в виде мультиплексирования

---

### Что такое мультиплексирование I/O
Мультиплексирование I/O - предоставляет задачу проверки готовности сокетов для операций чтения/записи **ядру**, а не самому разработчику.

В Linux используются доступны select, poll, epoll.
Все эти механизмы могут работать как с блокирующими сокетами, так и неблокирующими.

---

### Применение select к неблокирующим сокетам
Здесь мы рассмотрим, как решить проблему многократного опроса неблокирующих сокетов с помощью одного из механизмов мультиплексирования select

Select лучше всего сочетается с неблокирующими сокетами.

Допустим, что мы вызвали select с множеством блокирующих сокетов. Тогда, если объем данных слишком большой, а буфер чтения маленький, то нам придется вызвать select много раз.
Ведь если сокет блокирующий, то он будет заблокирован, пока другая сторона не прочитает данные, а в случае с неблокирующим возможно не дожидаясь готовности записи слать данные в
сокет.

(Например, сравнение:
    Условие: Объем данных - 1024 байта. Буффер - 64 байта.
    *В случае с блокирующим сокетом*: придется вызвать функцию select 64 раза - и прочитать за каждую итерацию очередные 64 байта.
    *В случае с неблокирующим сокетом*: select будет вызвана всего 1 раз - и прочитаем данные за 1 вызов select 64 раза на стороне программы)

---

### Что такое select
Ключевой модуль select - это структура *fd_set*. Мы загружаем в fd_set все наши сокеты и вызываем функцию select, передавая в качестве параметра наше множество сокетов (структуру
fd_set). На этом моменте программа блокируется, ожидая ответа (на проверку) от ядра.

#### Принципы работы select

**Имплементация set_fd:**

```c
#ifndef FD_SETSIZE
#define FD_SETSIZE  1024
#endif
#define NBBY    8       /* number of bits in a byte */
typedef long    fd_mask;
#define NFDBITS (sizeof (fd_mask) * NBBY)   /* bits per mask */
#define howmany(x,y)    (((x)+((y)-1))/(y))
typedef struct _types_fd_set {
    fd_mask fds_bits[howmany(FD_SETSIZE, NFDBITS)];
} _types_fd_set;

#define fd_set _types_fd_set
```

1) Select не хранит номер файлового дескриптора напрямую. Вместо этого для определения сокета используется всего 1 поле битов размера FD_SETSIZE (которое фиксировано на 1024),
которое состоит из множества long значений. Оно хранится в самой структуре fd_set.

При вызове *FD_SET* происходит назначение бита в бит поле с индексом int-значения сокета на 1.

Допустим, что есть 3 сокета с номерами 3, 7 и 15. Тогда бит поле будет выглядеть так:

```   1 long            2 long            3 long            4 long
00010001.00000001:00000000.00000000:00000000.00000000:00000000.00000000:....
   ^   ^        ^
   0   0        1
   3   7        5
```

2) Select полностью перезаписывает множество fd_set, то есть на каждой итерации или придется добавлять все сокеты снова в множество, или же восстанавливать предварительно
сохранненую копию множества функцией *FD_COPY(&fdset_orig, &fdset_copy)*.

---

### Что такое poll

Существенное достоинство по сравнению с select - нет лимита на количество сокетов.
Он хуже epoll, так как работает только в level-triggered режиме, и соответственно его сложность - это O(n), так как приходится проходить по всем сокетам и проверять их.

#### Принципы работы poll

В качестве множества сокетов используется *массив структур **pollfd***

**Для начала, имплементация структуры pollfd:**

```c++
struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that occurred
};
```

1) Из-за особенности устройства структуры pollfd poll не изменяет исходное множество и не перезаписывает его (хоть копирования в ядро происходят также),
что избавляет от лишних расходов на повторное копирование сокетов в множество на каждой итерации. Это достигается просто путем очищения значения revents в каждоый структуре
исходного массива.

2) poll, в отличие от select, использует для каждого сокета свою структуру и не хранит бит поля для определения номера сокета.

Хорошо ли это? Очевидно, нет.
Это зависит от количества сокетов.

Допустим, что у нас есть *<1024* (ограничение FD_SETSIZE select'а) сокетов - 128, произошло около 1000 итераций.
Давайте произведем расчеты:

**select:** произошло копирование в ядро 1024*1000 бит = *1024000 бит*

**poll:** произошло копирование в ядро (32int + 16short + 16short) * 128 * 1000 бит = *8192000 бит*

Очевидно, что poll будет проигрывать в затратах на копирование, однако, не стоит забывать, что в случае с select существует также затраты и на повторное копирование на каждой
итерации, в отличие от poll. Но не все так просто:

3) Однако, часто никогда не используется единственная структура fd_set для всех сокетов. Ведь в select нет возможности отслеживать, что произошло на сокете -
input или putput (read/write), или же исключение. Поэтому в имплементации приложений, использующих select в качестве мультиплексора используется 3 отдельных множества для
чтения, записи и исключений - *fd_set readfds*, *fd_set writefds*, *fd_set errorfds* соответственно. Из самого же объявления данной функции мы можем видеть это:
```c++
int select(int nfds, fd_set *restrict readfds,
       fd_set *restrict writefds, fd_set *restrict errorfds,
       struct timeval *restrict timeout);
```

Поэтому все затраты на копирование возрастают в 3 раза. Однако, при ожидаемом кол-ве сокетов *<1024* все же рекомендуется **использовать select**.

---

### Что такое epoll

**Epoll** - наиболее эффективный и более новый, однако также и более сложный в обращении мультиплексор, доступный только в Linux. Также это единственный event-based мультиплексор
в Linux.

Epoll способен работать в двух режимах:
    1) level-triggered
    2) edge-triggered <- именно из-за поддержки данного режима epoll можно назвать event-based мультиплексором

#### level-triggered режим epoll
При работе в таком режиме на вызове epoll будут возвращаться те файловые дескрипторы, в которых остались непрочитанные данные **со старого события**. То есть на прошлом
вызове мы по какой-то причине не прочитали все данные на сокетах, тогда при следующщей итерации на вызове epoll будут возвращены данные сокеты.

#### edge-triggered режим epoll
При работе в таком режиме будут возвращатья те файловые дескрипторы, где произошли **новые события**. Если даже программа прочитала не все данные на каком-либо из сокетов, то
она все равно будет заблокирована до наступления нового события.

#### Принципы работы epoll, почему он эффективнее других мультиплексоров
1) Во-первых, epoll эффективнее из-за другого, отличающегося от select и poll, механизма отслеживания активных сокетов и тредов.
Так как ядро знает все отслеживаемые дескрипторы, оно может регистрировать произошедшее событие на них, **даже если не было вызова *epoll_wait()***. Именно данная особенность
позволяет использовать *edge-triggering* режим работы мультиплесора. В результате этого возвращается не все множество, а только такое, где на сокетах произошли какие-либо события
 (event'ы).

2) epoll плохо подходит для работы с большим количеством коротко живущих соединений. Так как каждое принятое соединение требует вызова двух системных вызовов вместо одного
системного вызова в poll (так как требуется добавление в множество):

**epoll:** *accept() + epoll_ctl()*

**poll:** *accept()*

---

**Именно в *edge-triggering* режиме epoll становится особенно эфективным**

Рассмотрим поведения ядра на вызове *epoll_wait()* при режиме edge-triggered и сравним с поведением при *level-triggered*Д

- В случае level-triggered режима вызов epoll_wait будет проходить по списку дескрипторов и проверять, есть ли на каком либо из сокетов условие, которое позволит выйти из
epoll_wait без блокировки (если остались непрочитанные данные, например, и соответственно, доступно чтение)
- В случае edge-triggered же, такая проверка не производится, то есть нет необходимости проходить по всем сокетам, а будут отслеживаться только новые события, за счего чего
вызов становится намного эффективнее и сложность epoll становится O(1).

То есть, вызов epoll_wait будет более эффективным как раз потому, что не производится такой проверки и поток, из которого была вызвана функция *epoll_wait()* мгновенно
погружается в сон. **НО, при таком режиме, нужно читать обязательно **все данные, не оставляя непрочитанных**.*

---

### Select vs poll vs epoll
**Когда выбрать какой механизм?**

**Функциональность (select, poll):**
Select и poll предоставляют в основном одинаковую функциональность, однако есть и отличия.
1) *Select()* копирует множество, принимая его и возвращает обратно копию множества с выставленными флагами. Poll же, может работать с тем же множеством сокетов, который был передан
как аргумент в вызов *poll()*, избавляя от лишних расходов на копирование.
2) Poll может работать с большим количеством файлов (файловых дескрипторов), в то время как select имеет фиксированный размер множества - 1024, и не может быть изменен (на Linux).
3) poll предоставляет больший выбор ивентов по сравнению с select()
4) poll предоставляет возможность работы больше чем с 1024 сокетами

**Скорость:**
1) Оба, select и poll, работают *с файловыми дескрипторами* при вызове select() и poll() соответственно за O(n).
2) Затраты на копирование - чаще при маленьких кол-вах сокетов выиграет select (в select на каждый сокет тратится по *3 бита* (но остается фиксированным размер массива - 1024),
в отличие от *64 бит* в случае с poll)

**Когда выбирать select:**
1) Портативность приложения. Select - самый старый механизм мультиплексирования из доступных, поэтому можно быть полностью уверенным, что на каждой машине, где будет
запускатсья программа, она будет поддерживаться.
2) Трбеуется возможность работы с таймаутом в виде **наносекунд**, что невозможно в poll и epoll (там работа происходит с миллисекундами).

**Когда выбирать poll:**
1) Требуется поддержка платформ кроме Linux, и соотвественно невозможна работа с epoll
2) Принимаемые соединения живут *недолго*

**Когда выбирать epoll:**

1) Приложение использует *>1 потоков*, именно в таком приложении epoll раскрывает себя полностью. В сингл-тредном приложении использование epoll почти что не будет быстрее,
чем использование poll
2) Принимаемые соединения живут *долго*
3) Когда требуется возможность удалять/добавлять сокеты в множество даже, когда поток заблокирован на ожидании ивентов. Epoll поддерживает данную возможность, она официально
задокументирована.

### Как связан epoll с blocking и non-blocking I/O
В epoll в **edge-triggered** режиме нельзя использовать блокирующие сокеты потому, что **требуется прочитать абсолютно все имеющие на момент срабатывания ивента данные** и **нельзя
оставлять непрочитанные** на следующую итерацию и вызов epoll_wait(). А при использовании блокирующих сокетов, epoll не может проверить сокет на новые данные, так как требуется
прочесть уже передающиеся.

Поэтому при работе в режиме *edge-triggered* требуется использование non-blocking сокетов.

### Что такое event loop
Event loop относится к такой парадигме программирования, как *программирование с управлением по событиям* (event-driven programming).
Это означает то, что в потоке программы будут получаться не сами готовности чтения, записи (как мы делали в poll, select сервере), а *события* на них (например, щелчки мышкой,
нажатия клавиш). Все это регистрируется как ивент и в зависимости от ивента запускается принадлежащая ивенту *callback функция*.

В основе СОП (событийно ориентированного программирования) лежит как раз так и *event loop*.

### Как связан epoll с event loop
Так как epoll обладает режимом работы edge-triggering, а значит epoll - тоже относится к парадигме СОП, так как в edge-triggering epoll все завязано на событиях.

### Как связан event loop и асинхронность
В event loop все события обрабатываются в отдельной вызываемой *callback функции*, то есть каждый ивент обрабатывается своей callback функцией, поэтому не приходится ждать, пока
завершится обработка одного ивента, чтобы обработать следующий.

### Как связан epoll с асинхронностью


### Как связаны многопоточность и асинхронность


### Как связаны concurrency и асинхронность


### Как связаны многопоточность и concurrency











### Какая связь между epoll и многопоточностью


### Какая связь между epoll и concurrency


### Как работает node.js


### Как работает netty

